'''network builder for event-related tweets
using format provided by Chris Cassa and Megan Williams'''
import string, sys, time
import networkx as nx
import pylab as P

class NetworkBuilder(object):
    def __init__(self, network_hash=None, network_name=None):
        self.network_hash = network_hash
        self.network_name = network_name
        
    def make_networkx_from_nodexl(self, nodexl_file_name):
        #parse a NodeXL file into networkx
        self.nodexl_file = open(nodexl_file_name,'r')
        self.dataset_name = "/".join(nodexl_file_name.split("/")[:-1])
        self.image_path = self.dataset_name+"/net_images/"
        self.label_path = self.dataset_name+"/labels/"
        self.nodexl_graph = nx.DiGraph()
        self.node_properties_hash = {}
        self.edge_properties_hash = {}
        lctr = 0
        for line in self.nodexl_file:
            lctr+=1
            #skip header
            if lctr==1: continue
            #get columns
            components = line.strip().split(",")
            if len(components) != 15:
                print "badly formatted line"
                continue
            tweet_source,tweet_target,edge_type,has_link,has_call_number,created_at_tstamp,favorited,\
            lang,text,user_profile_description,user_created_at_tstamp,user_followers_count,\
            user_name,user_screen_name,user_time_zone = components                    
            if edge_type == "Reply":
                self.nodexl_graph.add_node(tweet_source)
                self.node_properties_hash[tweet_source] = {'text':text}
                clean_tweet_target = tweet_target.lstrip("@")                
                if clean_tweet_target != tweet_source:
                    self.nodexl_graph.add_node(clean_tweet_target)
                    self.nodexl_graph.add_edge(tweet_source,clean_tweet_target)  
                    self.edge_properties_hash[(tweet_source,clean_tweet_target)] = {'type':edge_type}
            #for retweets, switch source and target (if A RT B, then edge B->A) 
            #also label both source and target with text                 
            if edge_type == "Retweet":
                clean_tweet_target = tweet_target.lstrip("@")
                self.nodexl_graph.add_node(clean_tweet_target)
                self.node_properties_hash[clean_tweet_target] = {'text':text}
                if clean_tweet_target != tweet_source:
                    self.nodexl_graph.add_node(tweet_source)
                    self.node_properties_hash[tweet_source] = {'text':text}
                    self.nodexl_graph.add_edge(clean_tweet_target,tweet_source)         
                    self.edge_properties_hash[(clean_tweet_target,tweet_source)] = {'type':edge_type}
        self.nodexl_file.close()
        #set nodexl graph as object graph
        self.graph= self.nodexl_graph
        
    def extract_trees_from_graph(self):
        #print "starting topological sort at: ", time.time()
        #ntop = nx.topological_sort(self.graph)
        #print "ending topological sort at: ", time.time()
        #print "nodes by topology: ", ntop[:10]
        #return
        tree_hash = {}
        root_nodes = [x for x in self.graph if not self.graph.predecessors(x)]
        self.nodes_to_trees_hash = {}
        print "num root nodes: ", len(root_nodes)
        for rn in root_nodes:
            dfs_tree = nx.dfs_tree(self.graph, rn)            
            self.nodes_to_trees_hash[rn] = dfs_tree
        self.sorted_nodes_to_trees = sorted(self.nodes_to_trees_hash.items(), key=lambda x:len(x[1].nodes()), reverse=True)
        self.sorted_nodes_to_trees = [x for x in self.sorted_nodes_to_trees if len(x[1].nodes()) > 50]
        #print "num nodes by tree: ", [(k,len(v.nodes())) for k,v in self.sorted_nodes_to_trees if v]
        
    def store_network_hash_as_edgefile(self):
        #takes a network hash generated by tweet_parser and stores as edge file
        edge_file = open('%s_edge_file.csv' %(self.network_name),'w')
        edge_file.write("source,target,timestamp,text,edge_type")
        for e_source in self.network_hash:
            for e_target in self.network_hash[e_source]:
                for e_obj in self.network_hash[e_source][e_target]:
                    clean_text = string.replace(e_obj[1],",","")
                    edge_file.write("%s,%s,%s,%s,%s\n" %(e_source, e_target, e_obj[2], e_obj[1], e_obj[0]))
                    
    def draw_network(self):
        print "laying out fruchterman at: ", time.time()
        pos = nx.spring_layout(self.graph,iterations=100)
        print "done laying out fruchterman at: ", time.time()
        nx.draw(self.graph,pos=pos)
        P.show()
        
    def draw_trees(self):
        for i,ntt in enumerate(self.sorted_nodes_to_trees):
            for k_factor in [0.5,0.6]:
                #initialize figure
                P.figure(3,figsize=(18,18))
                P.axis('off')
            
                print "laying out fruchterman at: ", time.time()
                pos = nx.spring_layout(ntt[1],k=k_factor/(len(ntt[1].nodes())**0.5),iterations=500,scale=1)

                #pos = nx.fruchterman_reingold_layout(ntt[1],iterations=500,scale=18)
                print "done laying out fruchterman at: ", time.time()
            
            
                #draw nodes
                nx.draw_networkx_nodes(ntt[1],pos,nodelist=ntt[1].nodes(),node_color='b',node_size=50,alpha=0.8)

                #draw edges
                reply_edges = [e for e in ntt[1].edges() if self.edge_properties_hash[e]['type'] == 'Reply']
                retweet_edges = [e for e in ntt[1].edges() if self.edge_properties_hash[e]['type'] == 'Retweet']
                #draw reply edges
                nx.draw_networkx_edges(ntt[1],pos,edgelist=reply_edges,style='solid',width=1.0,alpha=0.5)
                #draw retweet edges
                nx.draw_networkx_edges(ntt[1],pos,edgelist=retweet_edges,style='dashed',width=1.0,alpha=0.5)
            
                #draw labels
                net_labels = {}
                for x in ntt[1]:
                    net_labels[x] = self.node_properties_hash.get(x,{'text':''})['text']
            
                #can't draw labels for now due to OSX bug   
                #nx.draw_networkx_labels(ntt[1],pos,net_labels)
                core_node = ntt[0].replace("/","")
                lbl_file_name = self.label_path+"labels_for_second_pass_component_%i_core_node_%s.txt" %(i, ntt[0])
                lbl_file = open(lbl_file_name,"w")
                for ntt_node in ntt[1]:
                    lbl_file.write("%s %s\n" %(ntt_node, net_labels[ntt_node]))
                lbl_file.close()

                P.savefig(self.image_path+"second_pass_component_%i_%f.png" %(i,k_factor))
                P.clf()
                #P.show()
        

def nodexl_network(fn):
    nb_nodexl = NetworkBuilder(None,None)
    nb_nodexl.make_networkx_from_nodexl(fn)
    print "num nodes: ", nb_nodexl.nodexl_graph.number_of_nodes(), " num edges: ", nb_nodexl.nodexl_graph.number_of_edges()
    nb_nodexl.extract_trees_from_graph()
    nb_nodexl.draw_trees()
    #nb_nodexl.draw_network()
    
if __name__ == '__main__':
    parse_options = sys.argv[1]
    #process nodexl file as networkx network
    if parse_options == "nodexl":
        #test_nodexl_file_name = "/Users/vdb5/Dropbox/real world tweets/Seattle_raw_tweets_candidates_nodexl.csv"
        test_nodexl_file_name = "/Users/vdb5/Documents/work/projects/chris cassa collaboration/Seattle_raw_tweets_candidates_precise_nodexl.csv"
        nodexl_network(test_nodexl_file_name)
            